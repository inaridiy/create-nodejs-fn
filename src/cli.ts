#!/usr/bin/env node
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import readline from "node:readline/promises";
import { cli, define } from "gunshi";

import { ensureDir, writeFileIfChanged } from "./fs-utils";

type InitOptions = {
  yes: boolean;
  force: boolean;
};

type InitAnswers = {
  name: string;
  main: string;
  className: string;
  binding: string;
  image: string;
  compatibilityDate: string;
  maxInstances: number;
};

type Prompter = {
  text: (message: string, defaultValue: string) => Promise<string>;
  number: (message: string, defaultValue: number) => Promise<number>;
  confirm: (message: string, defaultValue?: boolean) => Promise<boolean>;
  close: () => void;
};

const moduleDir =
  typeof __dirname === "string"
    ? __dirname
    : path.dirname(fileURLToPath(import.meta.url));
const pkgJsonPath = path.resolve(moduleDir, "../package.json");
const pkg = fs.existsSync(pkgJsonPath)
  ? JSON.parse(fs.readFileSync(pkgJsonPath, "utf8"))
  : { version: "0.0.0" };
const VERSION = pkg.version ?? "0.0.0";

const initCommand = define({
  name: "init",
  description: "Interactively scaffold create-nodejs-fn files",
  args: {
    yes: {
      type: "boolean",
      short: "y",
      description: "Use defaults and skip prompts",
    },
    force: {
      type: "boolean",
      short: "f",
      description: "Overwrite existing files without asking",
    },
  },
  run: async (ctx) => {
    const yes = Boolean(ctx.values.yes);
    const force = Boolean(ctx.values.force);
    await runInit({ yes, force });
  },
});

async function runInit(opts: InitOptions) {
  const cwd = process.cwd();
  const defaults = await gatherDefaults(cwd);
  const prompter = createPrompter(opts.yes);

  const answers: InitAnswers = {
    name: await prompter.text("Worker name", defaults.name),
    main: normalizeEntry(await prompter.text("Entry file", defaults.main)),
    className: await prompter.text("Container class name", defaults.className),
    binding: await prompter.text("Durable Object binding", defaults.binding),
    image: await prompter.text("Container image path", defaults.image),
    compatibilityDate: await prompter.text("Compatibility date", defaults.compatibilityDate),
    maxInstances: await prompter.number("Max container instances", defaults.maxInstances),
  };

  const results: string[] = [];

  if (await ensureDockerfile(cwd, opts, prompter)) {
    results.push(".create-nodejs-fn/Dockerfile");
  }

  if (updateGitignore(cwd)) {
    results.push(".gitignore");
  }

  if (ensureGeneratedDir(cwd)) {
    results.push("src/__generated__/");
  }

  const wranglerResult = await writeWranglerJsonc(cwd, answers, opts, prompter);
  if (wranglerResult) {
    results.push("wrangler.jsonc");
  }

  if (ensureEntryExportsDo(cwd, answers, opts)) {
    results.push(answers.main);
  }

  prompter.close();

  if (results.length === 0) {
    console.log("All files already up to date. Nothing to do.");
    return;
  }

  console.log("Updated:");
  for (const r of results) {
    console.log(`  - ${r}`);
  }

  printViteReminder();
}

async function ensureDockerfile(cwd: string, opts: InitOptions, prompter: Prompter) {
  const dockerfilePath = path.join(cwd, ".create-nodejs-fn", "Dockerfile");
  const dockerDir = path.dirname(dockerfilePath);
  ensureDir(dockerDir);

  if (fs.existsSync(dockerfilePath) && !opts.force) {
    const overwrite = await prompter.confirm(
      "Dockerfile already exists. Overwrite it?",
      false,
    );
    if (!overwrite) return false;
  }

  const content = [
    "# create-nodejs-fn container image",
    "# Generated by `create-nodejs-fn init`. The build step will refresh this file.",
    "FROM node:20-slim",
    "WORKDIR /app",
    "RUN corepack enable",
    "# Dependencies are injected via the generated package.json during build.",
    "COPY package.json ./",
    "RUN pnpm install --prod --no-frozen-lockfile",
    "# The server bundle is generated at build time.",
    "COPY ./server.mjs ./server.mjs",
    "ENV NODE_ENV=production",
    "EXPOSE 8080",
    'CMD ["node", "./server.mjs"]',
    "",
  ].join("\n");

  writeFileIfChanged(dockerfilePath, content);
  return true;
}

function updateGitignore(cwd: string) {
  const target = path.join(cwd, ".gitignore");
  const existing = fs.existsSync(target)
    ? fs.readFileSync(target, "utf8").split(/\r?\n/)
    : [];

  const block = [
    "# create-nodejs-fn",
    ".create-nodejs-fn/*",
    "!.create-nodejs-fn/Dockerfile",
    "src/__generated__",
  ];

  const lines = [...existing];
  const present = new Set(lines);
  const missing = block.filter((line) => !present.has(line));
  const changed = missing.length > 0;

  if (changed) {
    if (lines.length && lines[lines.length - 1] !== "") {
      lines.push("");
    }
    for (const line of block) {
      if (!present.has(line)) {
        lines.push(line);
      }
    }
  }

  if (changed) {
    const cleaned = trimBlankDuplicates(lines).join("\n");
    fs.writeFileSync(target, cleaned.endsWith("\n") ? cleaned : `${cleaned}\n`);
  }

  return changed;
}

function ensureGeneratedDir(cwd: string) {
  const dir = path.join(cwd, "src", "__generated__");
  if (fs.existsSync(dir)) return false;
  ensureDir(dir);
  return true;
}

async function writeWranglerJsonc(
  cwd: string,
  answers: InitAnswers,
  opts: InitOptions,
  prompter: Prompter,
) {
  const target = path.join(cwd, "wrangler.jsonc");
  const exists = fs.existsSync(target);

  if (exists && !opts.force) {
    const proceed = await prompter.confirm("wrangler.jsonc already exists. Merge updates?", true);
    if (!proceed) return false;
  }

  const existing = exists ? readJsonc(target) : {};
  const merged = mergeWranglerConfig(existing, answers);
  writeFileIfChanged(target, `${JSON.stringify(merged, null, 2)}\n`);
  return true;
}

function readJsonc(filePath: string): any {
  try {
    const raw = fs.readFileSync(filePath, "utf8");
    const withoutBlock = raw.replace(/\/\*[\s\S]*?\*\//g, "");
    const withoutLine = withoutBlock.replace(/(^|[^:])\/\/.*$/gm, "$1");
    return JSON.parse(withoutLine);
  } catch {
    return {};
  }
}

function mergeWranglerConfig(base: any, answers: InitAnswers) {
  const out: any = { ...base };
  out.$schema = out.$schema ?? "node_modules/wrangler/config-schema.json";
  out.name = out.name ?? answers.name;
  out.main = out.main ?? (answers.main.startsWith("./") ? answers.main : `./${answers.main}`);
  out.compatibility_date = out.compatibility_date ?? answers.compatibilityDate;

  const flags: string[] = Array.isArray(out.compatibility_flags) ? out.compatibility_flags : [];
  if (!flags.includes("nodejs_compat")) flags.push("nodejs_compat");
  out.compatibility_flags = flags;

  const containers = Array.isArray(out.containers) ? [...out.containers] : [];
  const containerIdx = containers.findIndex((c) => c?.class_name === answers.className);
  const containerEntry = {
    class_name: answers.className,
    image: answers.image,
    max_instances: answers.maxInstances,
  };
  if (containerIdx >= 0) {
    containers[containerIdx] = { ...containers[containerIdx], ...containerEntry };
  } else {
    containers.push(containerEntry);
  }
  out.containers = containers;

  const durable = typeof out.durable_objects === "object" && out.durable_objects !== null
    ? { ...out.durable_objects }
    : {};
  const bindings = Array.isArray(durable.bindings) ? [...durable.bindings] : [];
  const bindingIdx = bindings.findIndex((b) => b?.name === answers.binding);
  const bindingEntry = { name: answers.binding, class_name: answers.className };
  if (bindingIdx >= 0) {
    bindings[bindingIdx] = { ...bindings[bindingIdx], ...bindingEntry };
  } else {
    bindings.push(bindingEntry);
  }
  durable.bindings = bindings;
  out.durable_objects = durable;

  const migrations = Array.isArray(out.migrations) ? [...out.migrations] : [];
  const migIdx = migrations.findIndex((m) => m?.tag === "v1");
  const ensureNewSqlite = (entry: any) => {
    const classes = Array.isArray(entry.new_sqlite_classes) ? [...entry.new_sqlite_classes] : [];
    if (!classes.includes(answers.className)) classes.push(answers.className);
    entry.new_sqlite_classes = classes;
    return entry;
  };
  if (migIdx >= 0) {
    migrations[migIdx] = ensureNewSqlite({ ...migrations[migIdx], tag: migrations[migIdx].tag ?? "v1" });
  } else {
    migrations.push(ensureNewSqlite({ tag: "v1" }));
  }
  out.migrations = migrations;

  return out;
}

function ensureEntryExportsDo(cwd: string, answers: InitAnswers, opts: InitOptions) {
  const entryRel = answers.main.startsWith("./") ? answers.main.slice(2) : answers.main;
  const entryAbs = path.join(cwd, entryRel);
  ensureDir(path.dirname(entryAbs));

  const doAbs = path.join(cwd, "src", "__generated__", "create-nodejs-fn.do.ts");
  const doRel = path
    .relative(path.dirname(entryAbs), doAbs)
    .replace(/\\/g, "/")
    .replace(/\.ts$/, "");
  const exportLine = `export { ${answers.className} } from "${doRel.startsWith(".") ? doRel : `./${doRel}`}";`;

  if (fs.existsSync(entryAbs)) {
    const content = fs.readFileSync(entryAbs, "utf8");
    if (content.includes(exportLine) || content.match(new RegExp(`export\\s+\\{\\s*${answers.className}\\s*\\}.*create-nodejs-fn\\.do`))) {
      return false;
    }
    const next = content.endsWith("\n") ? `${content}${exportLine}\n` : `${content}\n${exportLine}\n`;
    writeFileIfChanged(entryAbs, next);
    return true;
  }

  const template = `${exportLine}\n`;
  writeFileIfChanged(entryAbs, template);
  return true;
}

async function gatherDefaults(cwd: string): Promise<InitAnswers> {
  const pkgPath = path.join(cwd, "package.json");
  const pkgJson = fs.existsSync(pkgPath)
    ? JSON.parse(fs.readFileSync(pkgPath, "utf8"))
    : {};

  return {
    name: pkgJson.name ?? path.basename(cwd),
    main: "src/index.ts",
    className: "NodejsFnContainer",
    binding: "NODEJS_FN",
    image: "./.create-nodejs-fn/Dockerfile",
    compatibilityDate: defaultCompatibilityDate(),
    maxInstances: 10,
  };
}

function defaultCompatibilityDate() {
  const d = new Date();
  const yyyy = d.getUTCFullYear();
  const mm = `${d.getUTCMonth() + 1}`.padStart(2, "0");
  const dd = `${d.getUTCDate()}`.padStart(2, "0");
  return `${yyyy}-${mm}-${dd}`;
}

function normalizeEntry(input: string) {
  if (!input) return "src/index.ts";
  const withSlash = input.startsWith("./") ? input : `./${input}`;
  return withSlash.replace(/\\/g, "/");
}

function createPrompter(skip: boolean): Prompter {
  if (skip || !process.stdin.isTTY) {
    return {
      text: async (_message, defaultValue) => defaultValue,
      number: async (_message, defaultValue) => defaultValue,
      confirm: async (_message, defaultValue = false) => defaultValue,
      close: () => {},
    };
  }

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return {
    async text(message, defaultValue) {
      const answer = await rl.question(formatPrompt(message, defaultValue));
      return answer.trim() || defaultValue;
    },
    async number(message, defaultValue) {
      const answer = await rl.question(formatPrompt(message, String(defaultValue)));
      const parsed = Number.parseInt(answer.trim(), 10);
      return Number.isFinite(parsed) ? parsed : defaultValue;
    },
    async confirm(message, defaultValue = false) {
      const suffix = defaultValue ? " [Y/n] " : " [y/N] ";
      const answer = (await rl.question(`${message}${suffix}`)).trim().toLowerCase();
      if (!answer) return defaultValue;
      return answer.startsWith("y");
    },
    close() {
      rl.close();
    },
  };
}

function formatPrompt(message: string, defaultValue: string | number) {
  const suffix = defaultValue !== undefined && defaultValue !== null ? ` (${defaultValue})` : "";
  return `${message}${suffix}: `;
}

function trimBlankDuplicates(lines: string[]) {
  const out: string[] = [];
  for (const line of lines) {
    if (line === "" && out.length > 0 && out[out.length - 1] === "") continue;
    out.push(line);
  }
  return out;
}

function printViteReminder() {
  console.log("\nNext step: add the plugin to your Vite config (vite.config.ts):");
  console.log("  import { createNodejsFnPlugin } from \"create-nodejs-fn\";");
  console.log("  export default defineConfig({ plugins: [createNodejsFnPlugin()] });");
}

async function main() {
  await cli(process.argv.slice(2), initCommand, {
    name: "create-nodejs-fn",
    version: VERSION,
  });
}

main().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
