import path from "node:path";
import { VariableDeclarationKind } from "ts-morph";
import { writeFileIfChanged } from "./fs-utils";
import { makeProject, printSource } from "./project-utils";
import type { DiscoveredModule } from "./types";

export type WorkerFileGenOptions = {
  gdirAbs: string;
  mods: DiscoveredModule[];
  root: string;
  binding: string;
  className: string;
  containerPort: number;
  workerEnvVars: string[] | Record<string, string>;
  clientFileName: string;
  doFileName: string;
  contextFileName: string;
  stubBatchFileName: string;
};

export function generateWorkerFiles(opts: WorkerFileGenOptions) {
  const {
    gdirAbs,
    mods,
    root,
    binding,
    className,
    containerPort,
    workerEnvVars,
    clientFileName,
    doFileName,
    contextFileName,
    stubBatchFileName,
  } = opts;

  const genProject = makeProject();
  const clientPath = path.join(gdirAbs, clientFileName);
  const doPath = path.join(gdirAbs, doFileName);
  const ctxPath = path.join(gdirAbs, contextFileName);

  // --- create-nodejs-fn.ts ---
  {
    const sf = genProject.createSourceFile(clientPath, "", { overwrite: true });
    sf.addStatements([
      "// AUTO-GENERATED. DO NOT EDIT.",
      "// Generated by vite-plugin-create-nodejs-fn.",
    ]);

    sf.addImportDeclaration({
      moduleSpecifier: `./${stubBatchFileName.replace(/\.ts$/, "")}`,
      namedImports: ["newHttpBatchRpcSession"],
    });

    sf.addImportDeclaration({
      moduleSpecifier: "cloudflare:workers",
      namedImports: ["env"],
    });

    sf.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      isExported: true,
      declarations: [{ name: "BINDING_NAME", initializer: JSON.stringify(binding) }],
    });

    for (const mod of mods) {
      const importRel = path
        .relative(path.dirname(clientPath), path.join(root, mod.fileRelFromRoot))
        .replace(/\\/g, "/")
        .replace(/\.tsx?$/, "");

      for (const ex of mod.exports) {
        const alias = `__T_${mod.namespace}_${ex.name}`;
        sf.addTypeAlias({
          name: alias,
          type: `typeof import(${JSON.stringify(importRel)}).${ex.name}`,
        });
      }

      sf.addInterface({
        isExported: true,
        name: `__NS_${mod.namespace}`,
        methods: mod.exports.map((ex) => {
          const alias = `__T_${mod.namespace}_${ex.name}`;
          return {
            name: ex.name,
            parameters: [{ name: "args", isRestParameter: true, type: `Parameters<${alias}>` }],
            returnType: `ReturnType<${alias}>`,
          };
        }),
      });
    }

    sf.addInterface({
      isExported: true,
      name: "FlatApi",
      extends: ["Rpc.RpcTargetBranded "],
      methods: mods.flatMap((mod) =>
        mod.exports.map((ex) => {
          const alias = `__T_${mod.namespace}_${ex.name}`;
          return {
            name: `${mod.namespace}__${ex.name}`,
            parameters: [{ name: "args", isRestParameter: true, type: `Parameters<${alias}>` }],
            returnType: `ReturnType<${alias}>`,
          };
        }),
      ),
    });

    sf.addInterface({
      isExported: true,
      name: "Containers",
      properties: mods.map((m) => ({ name: m.namespace, type: `__NS_${m.namespace}` })),
    });

    sf.addFunction({
      isExported: true,
      name: "rawClient",
      parameters: [{ name: "ctx", type: `{ containerKey?: string }` }],
      statements: `
const ns = env?.[BINDING_NAME];
if (!ns?.getByName) throw new Error(\`Container binding missing: \${BINDING_NAME}\`);
const stub = ns.getByName(ctx.containerKey ?? "default");
return newHttpBatchRpcSession<FlatApi>(stub);
      `,
    });

    const objLines: string[] = [];
    for (const mod of mods) {
      const lines = mod.exports.map(
        (ex) =>
          `${ex.name}: (...args: any[]) => (rpc as any)[${JSON.stringify(
            `${mod.namespace}__${ex.name}`,
          )}](...args),`,
      );
      objLines.push(`${mod.namespace}: { ${lines.join(" ")} },`);
    }

    sf.addFunction({
      isExported: true,
      name: "containers",
      parameters: [{ name: "ctx", type: `{ containerKey?: string }` }],
      returnType: "Containers",
      statements: `
const rpc = rawClient(ctx);
return { ${objLines.join(" ")} } as any;
      `,
    });

    writeFileIfChanged(clientPath, printSource(sf));
  }

  // --- create-nodejs-fn.do.ts ---
  {
    const sf = genProject.createSourceFile(doPath, "", { overwrite: true });
    sf.addStatements(["// AUTO-GENERATED. DO NOT EDIT."]);
    sf.addImportDeclaration({
      moduleSpecifier: "@cloudflare/containers",
      namedImports: ["Container"],
    });

    const envVarEntries = Array.isArray(workerEnvVars)
      ? workerEnvVars.map((n) => [n, n] as [string, string])
      : Object.entries(workerEnvVars);

    if (envVarEntries.length > 0) {
      sf.addImportDeclaration({ moduleSpecifier: "cloudflare:workers", namedImports: ["env"] });
    }

    const envVarInitializer =
      envVarEntries.length === 0
        ? undefined
        : `{\n${envVarEntries.map(([key, src]) => `  ${JSON.stringify(key)}: env[${JSON.stringify(src)}],`).join("\n")}\n}`;

    sf.addClass({
      isExported: true,
      name: className,
      extends: "Container",
      properties: [
        { name: "defaultPort", initializer: String(containerPort) },
        { name: "sleepAfter", initializer: JSON.stringify("10s") },
        ...(envVarInitializer ? [{ name: "envVars", initializer: envVarInitializer }] : []),
      ],
    });
    writeFileIfChanged(doPath, printSource(sf));
  }

  // --- create-nodejs-fn.context.ts ---
  {
    const sf = genProject.createSourceFile(ctxPath, "", { overwrite: true });
    sf.addStatements(["// AUTO-GENERATED. DO NOT EDIT."]);

    sf.addTypeAlias({
      name: "ContainerKey",
      type: `string | ((ctx: { request?: Request; env?: any; args: any[] }) => string | Promise<string>)`,
    });

    sf.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      declarations: [{ name: "registry", initializer: "new Map<string, ContainerKey>()" }],
    });

    sf.addFunction({
      isExported: true,
      name: "setContainerKey",
      parameters: [
        { name: "namespace", type: "string" },
        { name: "exportName", type: "string" },
        { name: "key", type: "ContainerKey" },
      ],
      statements: `registry.set(\`\${namespace}::\${exportName}\`, key);`,
    });

    sf.addFunction({
      isExported: true,
      name: "setNamespaceContainerKey",
      parameters: [
        { name: "namespace", type: "string" },
        { name: "key", type: "ContainerKey" },
      ],
      statements: `registry.set(\`\${namespace}::*\`, key);`,
    });

    sf.addFunction({
      isExported: true,
      name: "__resolveContainerKey",
      parameters: [
        { name: "namespace", type: "string" },
        { name: "exportName", type: "string" },
        { name: "ctx", type: `{ request?: Request; env?: any; args: any[] }` },
        { name: "fallback?", type: "ContainerKey" },
      ],
      returnType: "string | Promise<string>",
      statements: `
const direct = registry.get(\`\${namespace}::\${exportName}\`);
const ns = registry.get(\`\${namespace}::*\`);
const candidate = direct ?? ns ?? fallback;
if (typeof candidate === "function") return candidate(ctx);
if (typeof candidate === "string") return candidate;
return "default";
      `,
    });

    writeFileIfChanged(ctxPath, printSource(sf));
  }
}
